<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on kcindric</title>
        <link>https://www.kcindric.me/posts/</link>
        <description>Recent content in Posts on kcindric</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Wed, 16 Aug 2023 12:59:46 +0200</lastBuildDate>
        <atom:link href="https://www.kcindric.me/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Multiple Column PostgreSQL Full Text Search</title>
            <link>https://www.kcindric.me/posts/multiple-column-psql-full-text-search/</link>
            <pubDate>Wed, 16 Aug 2023 12:59:46 +0200</pubDate>
            
            <guid>https://www.kcindric.me/posts/multiple-column-psql-full-text-search/</guid>
            <description>In Part 1 of this tutorial about full text search using PostgreSQL, we talked about using functions such as to_tsquery and websearch_to_tsquery, which builds upon PostgreSQL ability to decompose longer sentences to smaller chunks called lexemes using tsquery.
Now we&amp;rsquo;re going to expand our knowledge and implement multi-column full text search and add indexes for a more performant search. In this next step we want to search film titles AND film descriptions using our dvdrental database.</description>
            <content type="html"><![CDATA[<p>In <a href="/posts/psql-full-text-search/">Part 1</a> of this tutorial about full text search using PostgreSQL, we talked about using functions such as <code>to_tsquery</code> and <code>websearch_to_tsquery</code>, which builds upon PostgreSQL ability to decompose longer sentences to smaller chunks called <em>lexemes</em> using <code>tsquery</code>.</p>
<p>Now we&rsquo;re going to expand our knowledge and implement multi-column full text search and add indexes for a more performant search. In this next step we want to search film titles AND film descriptions using our <code>dvdrental</code> database. In the stock database multi-column indexed search is already implemented but we&rsquo;re going to scrap that for the sake of this tutorial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">index</span> idx_fulltext;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> film <span style="color:#66d9ef">drop</span> <span style="color:#66d9ef">column</span> fulltext;
</span></span></code></pre></div><h2 id="creating-a-combined-tsvector-column">Creating a combined tsvector column</h2>
<p>Doing a full text search through multiple columns is easy as combining the <code>to_tsvector</code> results of wanted columns into one concatenated result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> to_tsvector(title) <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span>  to_tsvector(description) <span style="color:#66d9ef">as</span> fulltext 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-1.png" width="500"/>
</p>
<p style="text-align: center;">1000 rows</p>

<p>But in this approach each column has the same &lsquo;importance&rsquo; in our search. To optimize this we want to add more importance to our <code>title</code> column in front of the <code>description</code>. Fortunately, Postgres has this covered with the <code>setweight</code> function! This functions accepts two parameters, a <code>tsvector</code> value and a letter from A to D which determines the importance, or weight, of the column. Combining all this we get the following query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> setweight(to_tsvector(title), <span style="color:#e6db74">&#39;A&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span>  setweight(to_tsvector(description), <span style="color:#e6db74">&#39;B&#39;</span>) <span style="color:#66d9ef">as</span> fulltext
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-2.png" width="500"/>
</p>
<p style="text-align: center;">1000 rows</p>

<p>We could add <code>websearch_to_tsquery</code> to the mix from the <a href="/posts/psql-full-text-search/">Part 1</a> but the query would be too messy and hard to read. Instead, lets add a new column which is a calculated <code>tsvector</code> column from the combination of <code>title</code> and <code>description</code> and has a search weight added for prioritizing results. The best candidate are <em>generated columns</em>:</p>
<blockquote>
<p>A generated column is a special column that is always computed from other columns. Thus, it is for columns what a view is for tables. - PostgreSQL documentation</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">alter</span> <span style="color:#66d9ef">table</span> film 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">add</span> fulltext tsvector 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">generated</span> always <span style="color:#66d9ef">as</span>	(
</span></span><span style="display:flex;"><span>	setweight(to_tsvector(<span style="color:#e6db74">&#39;simple&#39;</span>, title), <span style="color:#e6db74">&#39;A&#39;</span>) <span style="color:#f92672">||</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">||</span>  setweight(to_tsvector(<span style="color:#e6db74">&#39;simple&#39;</span>, description), <span style="color:#e6db74">&#39;B&#39;</span>) :: tsvector
</span></span><span style="display:flex;"><span>) stored;
</span></span></code></pre></div><p>Note the added <code>simple</code> value in our <code>to_tsvector</code> function. We add this because PostgreSQL throws an exception if we explicitly define the &lsquo;regional configuration&rsquo; or a dictionary which will be used for deriving lexemes. Other options are <code>english</code>, <code>spanish</code> etc. Read more about that in the official PostgreSQL documentation.</p>
<p>Now we can easily search through both of our columns, giving priority to the <code>title</code> column using <code>websearch_to_tsquery</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, ts_rank(fulltext, websearch_to_tsquery(<span style="color:#e6db74">&#39;desert&#39;</span>)) <span style="color:#66d9ef">as</span> rank
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> fulltext <span style="color:#f92672">@@</span> websearch_to_tsquery(<span style="color:#e6db74">&#39;desert&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> rank <span style="color:#66d9ef">desc</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-3.png" width="700"/>
</p>
<p style="text-align: center;">44 rows</p>

<h2 id="indexes">Indexes</h2>
<p>When we do a <code>ANALYZE EXPLAIN</code> we can see that the PostgreSQL query profiler is not happy:</p>


<p align="center">
  <img src="images/query-profiler-1.png" width="700"/>
</p>
<p style="text-align: center;">Profiler is not happy</p>

<p>To optimize this query we can add an idex to our <code>fulltext</code> column. The most optimized index for a <code>tsvector</code> data type is called <code>GIN</code> and the following query will create one:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> search_fulltext <span style="color:#66d9ef">ON</span> film <span style="color:#66d9ef">USING</span> GIN(fulltext);
</span></span></code></pre></div><p>Now when we check the profiler we can see the results are much much better:</p>


<p align="center">
  <img src="images/query-profiler-2.png" width="700"/>
</p>
<p style="text-align: center;">Much better!</p>

<p>We got from 1.609ms to 0.144ms, that&rsquo;s a huge performance improvement!</p>
<h2 id="what-next">What next?</h2>
<p>In the next part we&rsquo;ll cover how to setup a REST API direct on top of our PostgreSQL db and do full text search on our data.</p>
]]></content>
        </item>
        
        <item>
            <title>Move PostgreSQL data folder to another disk on Windows</title>
            <link>https://www.kcindric.me/posts/psql-move-to-new-disk/</link>
            <pubDate>Thu, 10 Aug 2023 10:11:03 +0200</pubDate>
            
            <guid>https://www.kcindric.me/posts/psql-move-to-new-disk/</guid>
            <description>I&amp;rsquo;m running a PostgreSQL 12 instance as a Windows Service on one of my machines and one of the databases is getting too big (~72GB) for my C: drive. I have a great candidate for where to migrate my data - a nearly empty 1TB SSD attached to the machine.
The machine in question is my old Lenovo Thinkpad P51 laptop which I run 24/7 with the lid closed. It has some juciy specs for its time such as 32GB RAM and 4GB GPU.</description>
            <content type="html"><![CDATA[<p>I&rsquo;m running a PostgreSQL 12 instance as a Windows Service on one of my machines and one of the databases is getting too big (~72GB) for my <code>C:</code> drive. I have a great candidate for where to migrate my data - a nearly empty 1TB SSD attached to the machine.</p>
<p>The machine in question is my old Lenovo Thinkpad P51 laptop which I run 24/7 with the lid closed. It has some juciy specs for its time such as 32GB RAM and 4GB GPU. I plan to install Linux on it and use it as my home server but for now I&rsquo;m running stock Windows 10 + docker for some services I fiddle around.</p>
<h2 id="locating-the-data-folder-and-the-name-of-the-postgresql-service">Locating the data folder and the name of the PostgreSQL service</h2>
<p>To locate where our database data is stored a simple query is enough:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">SHOW</span> data_directory;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-1.png" width="300"/>
</p>
<p style="text-align: center;">Location of my data folder</p>

<p>Next step would be to stop the PostgreSQL service. We can do that by running <code>services.msc</code> and finding our service in the list:</p>


<p align="center">
  <img src="images/postgresql-old-service.png" width="600"/>
</p>
<p style="text-align: center;">Note: postgresql-x64-12 is the "real" name of the service, not the "Display Name". You can see that in the properties of the service inside the services app.</p>

<p>Stop the service and copy the <code>data</code> folder to the new location. In my case that&rsquo;s going to be <code>F:/psql</code>.</p>
<p><strong>Note:</strong> By stopping the service we avoid having corrupt data in our new <code>data</code> folder. This step is highly important!</p>
<h2 id="creating-a-new-postresql-service">Creating a new PostreSQL service</h2>
<p>PostgreSQL installation comes with a handy app called <code>pg_ctl</code> which we can run in our command line. We&rsquo;re going to use it to register our new service and un-register (delete) our old one.</p>
<p>To register our new service we need to run the following command where you substitute <code>postgresql-x64-12-new-service</code> with your desired service name and <code>F:/psql:/data</code> with the new path of your migrated <code>data</code> folder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>pg_ctl register -N postgresql-x64-12-new-service -D <span style="color:#e6db74">&#34;F:/psql/data&#34;</span>
</span></span></code></pre></div><p>What I usually do next is test was my migration and creation of the new PostgreSQL service successful by renameing the old <code>data</code> folder to something like <code>data_old</code>. Then I start my new service, if it&rsquo;s not already started, and try to connect to my PosgreSQL server and query a database. If all went well this should work seamlessly.</p>
<h2 id="deleting-the-old-service">Deleting the old service</h2>
<p>After testing that the migration went well we need to delete the old service by running the next command and including the name of the old service:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmd" data-lang="cmd"><span style="display:flex;"><span>pg_ctl unregister -N postgresql-x64-12
</span></span></code></pre></div><h2 id="cleanup">Cleanup</h2>
<p>After everything is done, I like to keep the <code>data_old</code> folder for a few days before deleting it. Call me paranoid but I like to have a backup plan if something goes wrong.</p>
]]></content>
        </item>
        
        <item>
            <title>PostgreSQL Full Text Search</title>
            <link>https://www.kcindric.me/posts/psql-full-text-search/</link>
            <pubDate>Sun, 06 Aug 2023 12:59:46 +0200</pubDate>
            
            <guid>https://www.kcindric.me/posts/psql-full-text-search/</guid>
            <description>Let&amp;rsquo;s say we are building an app for searching movies in our private collection. Our app, for simplicity, can only search movies using movie titles. In the following examples we&amp;rsquo;ll show a few different approaches how to do a full text search using PostgreSQL.
In this tutorial we&amp;rsquo;re going to use the sample database called &amp;ldquo;dvdrental&amp;rdquo; which can be found here.
Full Text Search using LIKE and ILIKE operators Let&amp;rsquo;s say we have a movie called &amp;ldquo;Darkness War&amp;rdquo; and we want to search it.</description>
            <content type="html"><![CDATA[<p>Let&rsquo;s say we are building an app for searching movies in our private collection. Our app, for simplicity, can only search movies using movie titles. In the following examples we&rsquo;ll show a few different approaches how to do a full text search using PostgreSQL.</p>
<p>In this tutorial we&rsquo;re going to use the sample database called &ldquo;dvdrental&rdquo; which can be found <a href="https://www.postgresqltutorial.com/postgresql-getting-started/postgresql-sample-database/">here</a>.</p>
<h2 id="full-text-search-using-like-and-ilike-operators">Full Text Search using LIKE and ILIKE operators</h2>
<p>Let&rsquo;s say we have a movie called &ldquo;Darkness War&rdquo; and we want to search it. The first, most easiest, and the least optimized way would be using the <code>LIKE</code> operator and wrapping individual words in <code>%</code> characters:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> film <span style="color:#66d9ef">where</span> title <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%darkness%&#39;</span> <span style="color:#66d9ef">or</span> title <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%war%&#39;</span>
</span></span></code></pre></div><p>The result:


<p align="center">
  <img src="images/sql-results-1.png" width="300"/>
</p>
<p style="text-align: center;">11 rows</p>
</p>
<p>11 results, but we&rsquo;re missing our desired title - the reason is that <code>LIKE</code> is case sensitive. To fix that, let&rsquo;s use <code>ILIKE</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">from</span> film <span style="color:#66d9ef">where</span> title <span style="color:#66d9ef">ilike</span> <span style="color:#e6db74">&#39;%darkness%&#39;</span> <span style="color:#66d9ef">or</span> title <span style="color:#66d9ef">ilike</span> <span style="color:#e6db74">&#39;%war%&#39;</span>
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-2.png" width="300"/>
</p>
<p style="text-align: center;">20 rows</p>

<p>Now we got our wanted result, but the list seems un-ordered and we miss a ranking system which of the results is a better match to our search query.</p>
<h2 id="enter-tsvector">Enter tsvector</h2>
<p>So this is the star of the tutorial. PostgreSQL documentation states the following:</p>
<blockquote>
<p>A <code>tsvector</code> value is a sorted list of distinct lexemes, which are words that have been normalized to merge different variants of the same word.</p>
</blockquote>
<p>We all heard about tokens in this AI language model age, and tokens in a sentence are simply words. Lexems are <em>normalized</em> tokens (words) of a sentence - this normalization may include converting all characters to lowercase, removing punctuation, and applying stemming (reducing words to their root form) to account for variations of the same word.</p>
<p>A <code>tsvector</code> is an ordered list of lexemes, along with their positions and weights. The weights indicate the importance of a particular lexeme concerning the relevance of a document in a search query. A <code>tsvector</code> is essentially an optimized, compressed representation of the lexemes present in a document, which allows for faster full-text searches.</p>
<p>Enough of theory, let&rsquo;s get our hands dirty!</p>
<p>We can use the <code>to_tsvector</code> function to parse text and turn into a tsvector for us:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> to_tsvector(<span style="color:#e6db74">&#39;I refuse to answer that question on the grounds that I don&#39;&#39;t know the answer.&#39;</span>);
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-3.png" width="600"/>
</p>

<p>We can also do this to our film titles:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, to_tsvector(title) <span style="color:#66d9ef">from</span> film <span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">10</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-4.png" width="300"/>
</p>

<p>To utilize <code>to_tsvector</code> in our full text search engine we&rsquo;re going to use two additional functions - <code>to_tsquery</code> and <code>ts_rank</code>.
<code>to_tsquery</code> helps us query plain text against a <code>tsvector</code> while <code>ts_rank</code> returns how well our query matches the result. Combining those two in a query we can get ranked results back:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, ts_rank(to_tsvector(title), to_tsquery(<span style="color:#e6db74">&#39;darkness&#39;</span>)) <span style="color:#66d9ef">as</span> rank
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> to_tsvector(title) <span style="color:#f92672">@@</span> to_tsquery(<span style="color:#e6db74">&#39;darkness&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> rank <span style="color:#66d9ef">desc</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-5.png" width="300"/>
</p>
<p style="text-align: center;">20 rows</p>

<p>Let&rsquo;s try and expand our query and find &ldquo;Darkness War&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, ts_rank(to_tsvector(title), to_tsquery(<span style="color:#e6db74">&#39;darkness war&#39;</span>)) <span style="color:#66d9ef">as</span> rank
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> to_tsvector(title) <span style="color:#f92672">@@</span> to_tsquery(<span style="color:#e6db74">&#39;darkness war&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> rank <span style="color:#66d9ef">desc</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-6.png" width="300"/>
</p>
<p style="text-align: center;">Syntax error</p>

<p>Uh-oh! We&rsquo;re getting back a syntax error because <code>to_tsquery</code> only accepts single words without spaces or as the PostgreSQL documentation states:</p>
<blockquote>
<p><code>to_tsquery</code> creates a <code>tsquery</code> value from querytext, which must consist of single tokens separated by the tsquery operators <code>&amp;</code> (AND), <code>|</code> (OR), <code>!</code> (NOT), and <code>&lt;-&gt;</code> (FOLLOWED BY), possibly grouped using parentheses.</p>
</blockquote>
<p>In other words, we could search for &ldquo;Darknes Wars&rdquo; by formating our query like <code>to_tsquery('darkness&lt;-&gt;wars')</code> but that would be cumbersome to do each time in the SQL query or messy doing it programatically inside our app.</p>
<p>The solution? <code>websearch_to_tsquery</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, ts_rank(to_tsvector(title), websearch_to_tsquery(<span style="color:#e6db74">&#39;darkness war&#39;</span>)) <span style="color:#66d9ef">as</span> rank
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> to_tsvector(title) <span style="color:#f92672">@@</span> websearch_to_tsquery(<span style="color:#e6db74">&#39;darkness war&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> rank <span style="color:#66d9ef">desc</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-7.png" width="300"/>
</p>
<p style="text-align: center;">1 result</p>

<p><code>websearch_to_tsquery</code> is a really powerful function and it&rsquo;s the function I personally like to use the most when using PostgreSQL as my full text search engine. It supports operators inside the query text:</p>
<ul>
<li><code>&quot;quoted text&quot;</code>: text inside quote marks will be converted to terms separated by <code>&lt;-&gt;</code> operators. Also, stop words are not simply discarded, but are accounted for.</li>
<li><code>OR</code>: the word “or” will be converted to the <code>|</code> operator.</li>
<li><code>+</code>: a plus will be converted to the <code>&amp;</code> operator.</li>
<li><code>-</code>: a dash will be converted to the <code>!</code> operator.</li>
</ul>
<p>This can be utilized greatly to expand your search engine. For example, let&rsquo;s search for movies that have a word &ldquo;darkness&rdquo; in it but do not have the word &ldquo;war&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-SQL" data-lang="SQL"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> title, ts_rank(to_tsvector(title), websearch_to_tsquery(<span style="color:#e6db74">&#39;&#34;darkness&#34; -war&#39;</span>)) <span style="color:#66d9ef">as</span> rank
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">from</span> film
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span> to_tsvector(title) <span style="color:#f92672">@@</span> websearch_to_tsquery(<span style="color:#e6db74">&#39;&#34;darkness&#34; -war&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> rank <span style="color:#66d9ef">desc</span>;
</span></span></code></pre></div>

<p align="center">
  <img src="images/sql-results-8.png" width="300"/>
</p>
<p style="text-align: center;">1 result</p>

<h2 id="what-next">What next?</h2>
<p>In <a href="/posts/multiple-column-psql-full-text-search/">Part 2</a> we cover indexes and full text search through multiple columns. After doing that, in Part 3 we&rsquo;re going to cover how to quickly create an REST api on top of our database using <a href="https://postgrest.org/">PostgREST</a> and perform our full text search from a client app.</p>
]]></content>
        </item>
        
    </channel>
</rss>
